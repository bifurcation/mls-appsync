



Messaging Layer Security                                       R. Barnes
Internet-Draft                                                     Cisco
Intended status: Informational                                   R. Mahy
Expires: 31 May 2025                      Rohan Mahy Consulting Services
                                                        27 November 2024


          An Application Interface to Messaging Layer Security
                    draft-barnes-mls-appsync-latest

Abstract

   The Messaging Layer Security protocol enables a group of participants
   to negotiate a common cryptographic state.  While the primary
   function of MLS is to establish shared secret state for the group, an
   MLS group also captures authentication information for group
   participants and information on which the group has confirmed
   agreement.  This document defines an interface interface by which
   multiple uncoordinated application functions may safely reuse the
   cryptographic state of an MLS group for application purposes.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://bifurcation.github.io/mls-appsync/draft-barnes-mls-
   appsync.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-barnes-mls-appsync/.

   Discussion of this document takes place on the Messaging Layer
   Security Working Group mailing list (mailto:mls@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/mls/.  Subscribe
   at https://www.ietf.org/mailman/listinfo/mls/.

   Source for this draft and an issue tracker can be found at
   https://github.com/bifurcation/mls-appsync.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 31 May 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Protocol Overview
   4.  Application Component Interface
   5.  Security Considerations
   6.  IANA Considerations
   7.  ========= OLD CONTENT BELOW THIS LINE ==========
   8.  Introduction
   9.  Conventions and Definitions
   10. Application State Synchronization
   11. Security Considerations
   12. IANA Considerations
   13. References
     13.1.  Normative References
     13.2.  Informative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   The Messaging Layer Security protocol (MLS) is designed to be
   integrated into applications, in order to provide security services
   that the application requires [RFC9420].  There are two questions to
   answer when designing such an integration:

   1.  How does the application provide the services that MLS requires?

   2.  How does the application use MLS to get security benefits?

   The MLS Architecture describes the requirements for the first of
   these questions [I-D.mls-architecture], namely the structure of the
   Delivery Service and Authentication Service that MLS requires.  This
   document is focused on the second question.

   MLS itself offers some basic functions that applications can use,
   such as the secure message encapsulation (PrivateMessage), the MLS
   exporter, and the epoch authenticator.  Current MLS applications make
   use of these mechanisms to acheive a variety of confidentiality and
   authentication properties.

   As application designers become more familiar with MLS, there is
   increasing interest in leveraging otehr cryptographic tools that an
   MLS group provides:

   *  HPKE and signature key pairs for each member, where the private
      key is known only to that member, and the public key is
      authenticated to the other members.

   *  A pre-shared key mechanism that can allow an application to inject
      data into the MLS key schedule.

   *  An exporter mechanism that allows applications to derive secrets
      from the MLS key schedule.

   There is also interest in exposing an MLS group to multiple loosely-
   coordinated components of an application.  To support these use
   cases, there is a need for a mechanism that provides application
   components access to MLS's cryptographic tools in a way that ensure
   that different components' usage will not conflict with each other,
   or with MLS itself.

   This document defines a set of mechanisms that application components
   can use to ensure that their use of these facilities is properly
   domain-separated from MLS itself, and from other application
   components that might be using the same MLS group.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   We make heavy use of the terminology in the MLS specification
   [RFC9420].

   Application:  The system that instantiates, manages, and uses an MLS
      group.  Each MLS group is used by exactly one application, but an
      application may maintain multiple groups.

   Application component:  A subsystem of an application that has access
      to an MLS group.

3.  Protocol Overview

   The mechansms in this document take MLS mechanisms that are either
   not inherently designed to be used by applications, or not inherently
   designed to be used by multiple application components, and adds a
   domain separator that separates application usage from MLS usage, and
   application components' usage from each other:

   *  Signing operations are tagged so that signatures will only verify
      in the context of a given component.

   *  Public-key encryption operations are similarly tagged so that
      encrypted data will only decrypt in the context of a given
      component.

   *  Pre-shared keys are identified as originating from a specific
      component, so that differnet components' contributions to the MLS
      key schedule will not collide.

   *  Exported values include an identifier for the component to which
      they are being exported, so that different components will get
      different exported values.

   Application components can use these functions to create advanced
   security services.  The signing and public-key encryption functions,
   for example, could be used to create a simple facility for
   authenticated one-to-one messaging within a group.  An application
   might export different values for encrypting real-time media with
   with SFrame [RFC9605], or for encrypting information that is not
   expected to be forward-secret within in epoch (e.g., a room title).

   Pre-shared keys are an especially flexible facility.  The
   PreSharedKeyID structure used to signal the use of a PSK in a
   Proposal or Welcome message can carry arbitary application data (in
   the psk_id field for external PSKs).  Since both the PreSharedKeyID
   and the secret PSK value are incorporated into the MLS key schedule,
   PSKs can be used to incorporate application data into the MLS key
   schedule, so that the continued functioning of the MLS group confirms
   that the entire group agrees on the application data.

   For example, suppose an application component wanted to confirm the
   group's agreement on an application-level policy document before
   enforcing the policy.  The application component wishing to update
   the policy could cause a Commit to be emitted that includes a
   PreSharedKey proposal whose PreSharedKeyID contains the new policy
   (with a arbitrary application defined PreSharedKey secret, possibly
   empty).  When another member successfully processes this commit, the
   corresponding application component at that member would see that the
   PSK proposal had confirmed agreement the new application policy, and
   put the policy into force.

4.  Application Component Interface

5.  Security Considerations

6.  IANA Considerations

7.  ========= OLD CONTENT BELOW THIS LINE ==========

8.  Introduction

   Messaging Layer Security (MLS) allows a group of clients to
   authenticate each other and establish shared secret state [RFC9420].
   One of the primary security benefits of MLS is that the MLS key
   schedule confirms that the group agrees on certain metadata, such as
   the membership of the group.  Members that disagree on the relevant
   metadata will arrive at different keys and be unable to communicate.
   Applications based on MLS can integrate their state into this
   metadata in order to confirm that the members of an MLS group agree
   on application state as well as MLS metadata.

   Here, we define two extensions to MLS to facilitate this application
   design:

   1.  A GroupContext extension application_states that confirms
       agreement on application state from potentially multiple sources.

   2.  A new proposal type AppSync that allows MLS group members to
       propose changes to the agreed application state.

9.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

10.  Application State Synchronization

   This document defines a new AppSync proposal.  AppSync is a Safe
   Extension as defined in Section 2 of [I-D.ietf-mls-extensions], of
   type extension_external_proposal.

   The application_states extension allows the application to inject
   state objects into the MLS key schedule.  Changes to this state can
   be made out of band, or using the AppSync proposal.  Using the
   AppSync proposal ensures that members of the MLS group have received
   the relevant state changes before they are reflected in the group's
   application_states.

      *NOTE:* This design exposes the high-level structure of the
      application state to MLS.  An alternative design would be to have
      the application state be opaque to MLS.  There is a trade-off
      between generality and the complexity of the API between the MLS
      implementation and the application.  An opaque design would give
      the application more freedom, but require the MLS stack to call
      out to the application to get the updated state as part of Commit
      processing.  This design allows the updates to happen within the
      MLS stack, so that no callback is needed, at the cost of forcing
      the application state to fit a certain structure.  It also
      potentially can result in smaller state updates in large groups.

   The state for Each applicationId in the application_states needs to
   conform to one of four basic types: an ordered array, an unordered
   array, a map, or an irreducible blob.  This allows the AppSync
   proposal to efficiently modify a large application state object.

   The content of the application_states extension and the AppSync
   proposal are structured as follows:

   enum {
       irreducible(0),
       map(1),
       unorderedList(2),
       orderedArray(3),
       (255)
   } StateType;

   struct {
     opaque element<V>;
   } OpaqueElement;

   struct {
     opaque elementName<V>;
     opaque elementValue<V>;
   } OpaqueMapElement;

   struct {
     uint32 applicationId;
     StateType stateType;
     select (stateType) {
       case irreducible:
         OpaqueElement state;
       case map:
         OpaqueMapElement mapEntries<V>;
       case unorderedList:
         OpaqueElement unorderedEntries<V>;
       case orderedArray:
         OpaqueElement orderedEntries<V>;
     };
   } ApplicationState;

   struct {
     ApplicationState applicationStates<V>;
   } ApplicationStatesExtension;

                Figure 1: The `application_state` extension

   struct {
     uint32 index;
     opaque element<V>;
   } ElementWithIndex;


   struct {
     uint32 applicationId;
     StateType stateType;
     select (stateType) {
       case irreducible:
         OpaqueElement newState;
       case map:
         OpaqueElement removedKeys<V>;
         OpaqueMapElement newOrUpdatedElements<V>;
       case unorderedList:
         uint32 removedIndices<V>;
         OpaqueElement addedEntries<V>;
       case orderedArray:
         ElementWithIndex replacedElements<V>;
         uint32 removedIndices<V>;
         ElementWithIndex insertedElements<V>;
         OpaqueElement appenededEntries<V>;
     };
   } AppSync;

                    Figure 2: The AppSync proposal type

   The applicationId determines the structure and interpretation of the
   contents. of an ApplicationState object.  AppSync proposals contain
   changes to this state, which the client uses to update the
   representation of the state in application_states.

   A client receiving an AppSync proposal applies it in the following
   way:

   *  Identify an application_states GroupContext extension which
      contains the same application_id state as the AppSync proposal

   *  Apply the relevant operations (replace, remove, update, append,
      insert) according to the stateType to the relevant parts of the
      ApplicationState object in application_states extension.

   An AppSync for an irreducible state replaces its state element with a
   new (possibly empty) newState.  An AppSync for a map-based
   ApplicationState first removes all the keys in removedKeys and than
   replaces or adds the elements in newOrUpdatedElements.  An AppSync
   for an unorderedList ApplicationState first removes all the indexes
   in removedIndices, then adds the elements in addedEntries.  Finally
   an AppSync for an orderedArray, replaces all the elements (index-by-
   index) in replacedElements, the removes the elements in
   removedIndices according to the then order of the array, then inserts
   all the elements in insertedElements according to the then order of
   the array, then finally appends the appendedEntries (in order).  All
   indices are zero-based.

   Note that the application_states extension is updated directly by
   AppSync proposals; a GroupContextExtensions proposal is not
   necessary.  A proposal list that contains both an AppSync proposal
   and a GroupContextExtensions proposal is invalid.

   Likewise a proposal list in a Commit MAY contain more than one
   AppSync proposal, but no more than one AppSync proposal per
   applicationId.  The proposals are applied in the order that they are
   sent in the Commit.

   AppSync proposals do not need to contain an UpdatePath.  An AppSync
   proposal can be sent by an authorized external sender.

11.  Security Considerations

   The mechanism defined in this document provides strong authenticity,
   integrity, and change control properties to the application state
   information it manages.  Nobody outside the group can make changes to
   the application state, and the identity of the group member making
   each change is authenticated.

   The application data synchronized via this mechanism may or may not
   be confidential to the group, depending on whether the AppSync
   proposal is sent as an MLS PublicMessage or PrivateMessage.  As with
   application data, applications should generally prefer the use of
   Private Message.  There may be cases, however, where it is useful for
   intermediaries to inspect application state updates, e.g., to enforce
   policy.

12.  IANA Considerations

      *TODO:* Register new extension and proposal types.

      *TODO:* IANA registry for application_id; register extension and
      proposal types as safe extensions

13.  References

13.1.  Normative References

   [I-D.ietf-mls-extensions]
              Robert, R., "The Messaging Layer Security (MLS)
              Extensions", Work in Progress, Internet-Draft, draft-ietf-
              mls-extensions-05, 21 October 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-mls-
              extensions-05>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9420]  Barnes, R., Beurdouche, B., Robert, R., Millican, J.,
              Omara, E., and K. Cohn-Gordon, "The Messaging Layer
              Security (MLS) Protocol", RFC 9420, DOI 10.17487/RFC9420,
              July 2023, <https://www.rfc-editor.org/rfc/rfc9420>.

13.2.  Informative References

   [I-D.mls-architecture]
              "*** BROKEN REFERENCE ***".

   [RFC9605]  Omara, E., Uberti, J., Murillo, S. G., Barnes, R., Ed.,
              and Y. Fablet, "Secure Frame (SFrame): Lightweight
              Authenticated Encryption for Real-Time Media", RFC 9605,
              DOI 10.17487/RFC9605, August 2024,
              <https://www.rfc-editor.org/rfc/rfc9605>.

Acknowledgments

      *TODO:* Acknowledgements.

Authors' Addresses

   Richard Barnes
   Cisco
   Email: rlb@ipv.sx


   Rohan Mahy
   Rohan Mahy Consulting Services
   Email: rohan.ietf@gmail.com
